/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class LibraryTest {
    @Test
    void instantiateTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        assertNull(newTree.root);
    }

    @Test
    void singleRootTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        assertNotNull(newTree.root);
    }

    @Test
    void singleRightAndLeft() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        Node<Integer> left = new Node<Integer>(15);
        Node<Integer> right = new Node<Integer>(30);
        newTree.root = root;
        newTree.root.left = left;
        newTree.root.right = right;

        String expected = "15 -> 22 -> 30 -> ";
        assertEquals(expected, newTree.inOrder(newTree.root));
    }

    @Test
    void preOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "22 -> 15 -> 17 -> 30 -> 25 -> ";
        assertEquals(expected, newTree.preOrder(newTree.root));
    }

    @Test
    void inOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "15 -> 17 -> 22 -> 25 -> 30 -> ";
        assertEquals(expected, newTree.inOrder(newTree.root));
    }

    @Test
    void postOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "17 -> 15 -> 25 -> 30 -> 22 -> ";
        assertEquals(expected, newTree.postOrder(newTree.root));
    }

    // Code Challenge 16 tests:
    @Test
    void maximumInTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();

        assertThrows(NullPointerException.class, () -> newTree.maxInTree());

        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        int expected = 30;
        assertEquals(expected, newTree.maxInTree());

        Node<Integer> newNode = new Node<Integer>(50);
        leftright.left = newNode;
        Node<Integer> newNode2 = new Node<Integer>(33);
        rightleft.left = newNode2;

        expected = 50;
        assertEquals(expected, newTree.maxInTree());
    }

    // Code Challenge 17 tests:
    @Test
    void BreadthFirstSearch() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();

        assertNull(newTree.treeBreadthFirst(newTree));

        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;

        assertEquals("[22]" , newTree.treeBreadthFirst(newTree).toString());

        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        assertEquals("[22, 15, 30, 17, 25]" , newTree.treeBreadthFirst(newTree).toString());
    }

    // Code Challenge 18 tests:
    @Test
    public void fizzbuzzTest(){
        KaryTree tree = new KaryTree(4);
        assertNull(tree.root);
        KNode root = new KNode("10");
        KNode node1 = new KNode("7");
        KNode node2 = new KNode("15");
        KNode node3 = new KNode("3");
        KNode node4 = new KNode("8");
        KNode node5 = new KNode("13");
        KNode node6 = new KNode("20");

        tree.root = root;

        root.children.add(node1);
        root.children.add(node2);

        node1.children.add(node3);

        node2.children.add(node4);
        node2.children.add(node5);
        node2.children.add(node6);

        tree.fizzBuzz(tree);

        assertEquals("Buzz", root.value);
        assertEquals("7", node1.value);
        assertEquals("FizzBuzz", node2.value);
        assertEquals("Fizz", node3.value);
        assertEquals("8", node4.value);
        assertEquals("13", node5.value);
        assertEquals("Buzz", node6.value);
    }

}

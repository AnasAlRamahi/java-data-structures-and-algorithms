/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class LibraryTest {
    @Test
    void instantiateTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        assertNull(newTree.root);
    }

    @Test
    void singleRootTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        assertNotNull(newTree.root);
    }

    @Test
    void singleRightAndLeft() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        Node<Integer> left = new Node<Integer>(15);
        Node<Integer> right = new Node<Integer>(30);
        newTree.root = root;
        newTree.root.left = left;
        newTree.root.right = right;

        String expected = "15 -> 22 -> 30 -> ";
        assertEquals(expected, newTree.inOrder(newTree.root));
    }

    @Test
    void preOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "22 -> 15 -> 17 -> 30 -> 25 -> ";
        assertEquals(expected, newTree.preOrder(newTree.root));
    }

    @Test
    void inOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "15 -> 17 -> 22 -> 25 -> 30 -> ";
        assertEquals(expected, newTree.inOrder(newTree.root));
    }

    @Test
    void postOrderTraversal() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();
        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        String expected = "17 -> 15 -> 25 -> 30 -> 22 -> ";
        assertEquals(expected, newTree.postOrder(newTree.root));
    }

    // Code Challenge 16 tests:
    @Test
    void maximumInTree() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();

        assertThrows(NullPointerException.class, () -> newTree.maxInTree());

        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;
        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        int expected = 30;
        assertEquals(expected, newTree.maxInTree());

        Node<Integer> newNode = new Node<Integer>(50);
        leftright.left = newNode;
        Node<Integer> newNode2 = new Node<Integer>(33);
        rightleft.left = newNode2;

        expected = 50;
        assertEquals(expected, newTree.maxInTree());
    }

    // Code Challenge 17 tests:
    @Test
    void BreadthFirstSearch() {
        BinaryTree<Integer> newTree = new BinaryTree<Integer>();

        assertNull(newTree.treeBreadthFirst(newTree));

        Node<Integer> root = new Node<Integer>(22);
        newTree.root = root;

        assertEquals("[22]" , newTree.treeBreadthFirst(newTree).toString());

        Node<Integer> left = new Node<Integer>(15);
        newTree.root.left = left;
        Node<Integer> right = new Node<Integer>(30);
        newTree.root.right = right;
        Node<Integer> leftright = new Node<Integer>(17);
        newTree.root.left.right = leftright;
        Node<Integer> rightleft = new Node<Integer>(25);
        newTree.root.right.left = rightleft;

        assertEquals("[22, 15, 30, 17, 25]" , newTree.treeBreadthFirst(newTree).toString());
    }
}

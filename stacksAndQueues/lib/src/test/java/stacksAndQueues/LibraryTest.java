/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stacksAndQueues;

import org.junit.jupiter.api.Test;

import java.util.EmptyStackException;

import static org.junit.jupiter.api.Assertions.*;

class LibraryTest {

    // Tests for Lab10:
    @Test void stackCanPush() {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(5);
        String expected = "TOP\n" +
                "{ 5 }\n" ;
        assertEquals(expected, stack.toString());
    }

    @Test void stackPushMultiple() {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(5);
        stack.push(4);
        stack.push(3);
        stack.push(2);
        stack.push(1);
        String expected = "TOP\n" +
                "{ 1 }\n" +
                "{ 2 }\n" +
                "{ 3 }\n" +
                "{ 4 }\n" +
                "{ 5 }\n";
        assertEquals(expected, stack.toString());
    }

    @Test void popOffStack() {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(1);
        assertEquals(1, stack.pop());
    }

    @Test void emptyStackWithPops() {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(5);
        stack.push(4);
        stack.push(3);
        stack.push(2);
        stack.push(1);

        stack.pop();
        stack.pop();
        stack.pop();
        stack.pop();
        stack.pop();
        assertTrue(stack.isEmpty());
    }

    @Test void stackPeekNext() {
        Stack<Integer> stack = new Stack<Integer>();
        stack.push(5);
        stack.push(4);
        stack.push(3);
        Integer expected = 3;
        assertEquals(expected, stack.top.value);
    }

    @Test void stackInstantiateEmpty() {
        Stack<Integer> stack = new Stack<Integer>();
        String expected = "TOP\n";
        assertEquals(expected, stack.toString());
    }

    @Test void peekEmptyException() {
        Stack<Integer> stack = new Stack<Integer>();
        assertThrows(EmptyStackException.class, () -> stack.peek());
    }


    @Test void enqueueOnce() {
        Queue<Character> q = new Queue<Character>();
        q.enqueue('a');
        String expected = "FRONT -> { a } -> REAR";
        assertEquals(expected, q.toString());
    }

    @Test void enqueueMultiple() {
        Queue<Character> q = new Queue<Character>();
        q.enqueue('a');
        q.enqueue('b');
        q.enqueue('c');
        q.enqueue('d');
        String expected = "FRONT -> { a } -> { b } -> { c } -> { d } -> REAR";
        assertEquals(expected, q.toString());
    }

    @Test void dequeueOne() {
        Queue<Character> q = new Queue<Character>();
        q.enqueue('a');
        q.enqueue('b');
        q.enqueue('c');
        Character expected = 'a';
        assertEquals(expected, q.dequeue());
    }

    @Test void peekTheQueue() {
        Queue q = new Queue<Character>();
        q.enqueue('b');
        q.enqueue('c');
        Character expected = 'b';
        assertEquals(expected, q.peek());
    }

    @Test void dequeueUntilEmpty() {
        Queue q = new Queue<Character>();
        q.enqueue('a');
        q.enqueue('b');
        q.enqueue('c');
        q.dequeue();
        q.dequeue();
        q.dequeue();
        assertNull(q.front);
    }

    @Test void instantiateEmptyQueue() {
        Queue q = new Queue<Character>();
        assertNull(q.front);
    }

    @Test void peekEmptyQueue() {
        Queue q = new Queue<Character>();
        assertThrows(EmptyStackException.class,  () -> q.peek());
    }


    // codeChallenge11 tests:
    @Test void pseudoQueueEnqueue() {
        PseudoQueue<Integer> q = new PseudoQueue<Integer>();
        assertEquals("NULL <- Front", q.toString());
    }

    @Test void pseudoQueueDequeueThrowException() {
        PseudoQueue<Integer> q = new PseudoQueue<Integer>();
        assertThrows(EmptyStackException.class,  () -> q.pseudoDequeue());
    }

    @Test void pseudoEnqueueOnce() {
        PseudoQueue<Character> q = new PseudoQueue<Character>();
        q.pseudoEnqueue('a');
        String expected = "NULL <- { a } <- Front";
        assertEquals(expected, q.toString());
    }

    @Test void pseudoEnqueueMultiple() {
        PseudoQueue<Character> q = new PseudoQueue<Character>();
        q.pseudoEnqueue('a');
        q.pseudoEnqueue('b');
        q.pseudoEnqueue('c');
        q.pseudoEnqueue('d');
        String expected = "NULL <- { d } <- { c } <- { b } <- { a } <- Front";
        assertEquals(expected, q.toString());
    }

    @Test void pseudoDequeueOnce() {
        PseudoQueue<Character> q = new PseudoQueue<Character>();
        q.pseudoEnqueue('b');
        q.pseudoEnqueue('a');
        q.pseudoDequeue();
        String expected = "NULL <- { a } <- Front";
        assertEquals(expected, q.toString());
    }

    @Test void pseudoDequeueMultiple() {
        PseudoQueue<Character> q = new PseudoQueue<Character>();
        q.pseudoEnqueue('a');
        q.pseudoEnqueue('b');
        q.pseudoEnqueue('c');
        q.pseudoEnqueue('d');
        q.pseudoEnqueue('e');
        q.pseudoDequeue();
        q.pseudoDequeue();
        q.pseudoDequeue();
        String expected = "NULL <- { e } <- { d } <- Front";
        assertEquals(expected, q.toString());
    }

    // codeChallenge12 tests:
    @Test
    void initializeQueue(){
        AnimalShelter as = new AnimalShelter();
        assertNull(as.animalQueue.front);
    }

    @Test
    void enqueueInShelter(){
        AnimalShelter as = new AnimalShelter();
        Cat c1 = new Cat("NimNim");
        as.enqueue(c1);
        String expected = "FRONT -> { Cat: NimNim } -> REAR";
        assertEquals(expected,as.animalQueue.toString());

        Cat c2 = new Cat("MishMish");
        Cat c3 = new Cat("Quora");
        Dog d1 = new Dog("Buck");
        Dog d2 = new Dog("Meezo");
        Dog d3 = new Dog("Keeko");

        as.enqueue(d1);

        as.enqueue(d2);
        as.enqueue(c2);

        as.enqueue(c3);
        as.enqueue(d3);

        expected = "FRONT -> { Cat: NimNim } -> { Dog: Buck } -> { Dog: Meezo } -> { Cat: MishMish } -> { Cat: Quora } -> { Dog: Keeko } -> REAR";
        assertEquals(expected,as.animalQueue.toString());
    }

    @Test
    void dequeueInShelter(){
        AnimalShelter as = new AnimalShelter();
        Cat c1 = new Cat("NimNim");
        Cat c2 = new Cat("MishMish");
        Cat c3 = new Cat("Quora");
        Dog d1 = new Dog("Buck");
        Dog d2 = new Dog("Meezo");
        Dog d3 = new Dog("Keeko");

        as.enqueue(c1);
        as.enqueue(d1);

        as.enqueue(d2);
        as.enqueue(c2);

        as.enqueue(c3);
        as.enqueue(d3);


        as.dequeue("cat");
        String expected = "FRONT -> { Dog: Buck } -> { Dog: Meezo } -> { Cat: MishMish } -> { Cat: Quora } -> { Dog: Keeko } -> REAR";
        assertEquals(expected,as.animalQueue.toString());

        as.dequeue("cat");
        expected = "FRONT -> { Dog: Buck } -> { Dog: Meezo } -> { Cat: Quora } -> { Dog: Keeko } -> REAR";
        assertEquals(expected,as.animalQueue.toString());

        as.dequeue("dog");
        expected = "FRONT -> { Dog: Meezo } -> { Cat: Quora } -> { Dog: Keeko } -> REAR";
        assertEquals(expected,as.animalQueue.toString());

        as.dequeue("cat");
        as.dequeue("dog");
        expected = "FRONT -> { Dog: Keeko } -> REAR";
        assertEquals(expected,as.animalQueue.toString());

    }

    @Test
    void wrongPreferredAnimal(){
        AnimalShelter as = new AnimalShelter();
        Cat c1 = new Cat("NimNim");
        Cat c2 = new Cat("MishMish");
        Dog d1 = new Dog("Buck");
        Dog d2 = new Dog("Meezo");

        as.enqueue(c1);
        as.enqueue(d1);
        as.enqueue(d2);
        as.enqueue(c2);

        assertNull(as.dequeue("something wrong"));
        assertNull(as.dequeue("cattt"));
        assertNull(as.dequeue("doogg"));
        assertNull(as.dequeue("dogcat"));

    }

}
